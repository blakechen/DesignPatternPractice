#[Name]
##Bridge

#[Context]
如果某個抽象體有好幾種可能的實作方式，我們常會用繼承方式去容納它們；先用抽象類別定議抽象體的介面 再用各種具象子類別去一一實作。可是這種方式的彈性末必很夠：繼承會把實作碼綁在抽象體身上 日後便很難個另加以修改、擴充、再利用

#[Problem]
要如何避免抽象體與實作體綁死在一起?EX:相在執行期仍能選擇或切換成不同的實作方式。

#[Force]
* 想避免將抽象體與實作體綁死在一起
* 希望能用子類別個別擴充抽象體與實作體。
* 如果有實作體有變、但抽象實體沒變時，就不應波及客戶碼

#[Solution]
將抽象體與實作體拆成兩個獨立的類別階層，一個負責制訂各種視窗的外介面，另一個則處理與特定視窗實作環境相關事宜。

#[Resulting Content]
抽象和實踐可以被各自擴充，不會影響到對方。
相當適合使用在需要跨越多個平台的圖形和視窗上。

***
#[Workshop]
